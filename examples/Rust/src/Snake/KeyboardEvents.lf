//! This Lingua Franca program captures asynchronous key press events in a terminal
//! and sends them through an output port. It is primarily designed to interact with
//! the arrow keys (up, down, left, right) and the Ctrl+C key combination. When the
//! program starts, it enters a raw mode, allowing it to capture individual key
//! presses. These key presses are then sent through the 'arrow_key_pressed' output.
//! If the Ctrl+C combination is detected, the program requests to stop. Upon
//! shutdown, the program exits the raw mode. This reactor is designed to support
//! other applications that require real-time keyboard interaction, particularly
//! within terminal-based interfaces.
//!
//! Support reactor for the Snake.lf example.
target Rust {
  cargo-dependencies: {
    termion: "1"
  }
}

/// Capture asynchronous key presses, and sends them through an output port.
/// Used by the other examples.
reactor KeyboardEvents {
  preamble {=
    use std::io::Stdout;

    use termion::event::Key;
    use termion::raw::{RawTerminal, IntoRawMode};
  =}

  output arrow_key_pressed: Key  /// The latest key press.

  physical action key_press: Key

  state raw_terminal: Option<RawTerminal<Stdout>>

  reaction(key_press) -> arrow_key_pressed {=
    ctx.set(arrow_key_pressed, ctx.get(key_press).unwrap());
  =}

  reaction(shutdown) {=
    drop(self.raw_terminal.take()) // exit raw mode
  =}

  reaction(startup) -> key_press {=
    let stdin = std::io::stdin();

    // enter raw mode, to get key presses one by one
    // this will stay so until this variable is dropped
    self.raw_terminal = Some(std::io::stdout().into_raw_mode().unwrap());

    let key_press = key_press.clone();
    ctx.spawn_physical_thread(move |link| {
      use termion::input::TermRead;

      for c in stdin.keys() {
        match c.unwrap() {
          k@(Key::Left | Key::Right | Key::Up | Key::Down) => {
            trace!("received {:?}", k);
            link.schedule_physical_with_v(&key_press, Some(k), Asap).ok();
          },
          Key::Ctrl('c') => {
            link.request_stop(Asap).unwrap();
            break;
          },
          k => {
            trace!("received {:?}", k);
          }
        }
      }
    });
  =}
}
