target C {
  single-threaded: true,
  keepalive: true,
  compiler-flags: "-lncurses"
}

/**
 * FIXME: there are still two problems with this implementation: 1. Use of a global variable to let
 * the ncurses thread find the actions that it should lf_schedule. It would be helpful to have some
 * kind of generic framework for setting up interactive tests. 2. When the program runs out of space
 * on the terminal, newlines are ignored. It is not clear to me why this is the case, but I've only
 * just now started using ncurses, which is a pretty rich toolkit. More on ncurses here:
 * http://web.mit.edu/barnowl/src/ncurses/ncurses-5.4/doc/html/ncurses-intro.html
 *
 * @author Marten Lohstroh
 */
preamble {=
  #include <stdio.h>
  #include <stdlib.h>
  #include <curses.h>

  struct {
    void* brake;
    void* accelerate;
  } pedals;

  int calc_brake_force(int angle) {  // ~0-600 Nm in Tesla Model 3
    return 110 * angle;
  }

  int calc_motor_torque(int angle) {
    return 100 * angle;
  }

  void* read_input(void* arg) {
    initscr();
    noecho();       // Don't echo input
    cbreak();      // Don't interrupt for user input
    timeout(1);    // Wait for key press in ms
    printw("***************************************************************\n");
    printw("Press '1-6' to change the angle of the accelerator\n");
    printw("Press 'q-y' to change the angle of the brake pedal\n");
    char c = 0;     // Command: [1-6|q-y]
    int v = 0;
    while (true) {
      bool skip = false; // Whether to lf_schedule and event or not
        c = getch();
        switch(c) {
        case 'q':
          v = 0;
          break;
        case 'w':
          v = 1;
          break;
        case 'e':
          v = 2;
          break;
        case 'r':
          v = 3;
          break;
        case 't':
          v = 4;
          break;
        case 'y':
          v = 5;
          break;
        default:
          skip = true;
          break;
      }

        if (!skip) {
        lf_schedule_int(pedals.brake, 0, v);
      }

         skip = false;
        switch(c) {
        case '1':
          v = 0;
          break;
        case '2':
          v = 1;
          break;
        case '3':
          v = 2;
          break;
        case '4':
          v = 3;
          break;
        case '5':
          v = 4;
          break;
        case '6':
          v = 5;
          break;
        default:
          skip = true;
          break;
      }

        if (!skip) {
        lf_schedule_int(pedals.accelerate, 0, v);
      }
     }
     endwin();
     return 0;
  }
  pthread_t curses_thread;
  bool initialized = false;
  void init_sensors() {
    if (!initialized) {
      pthread_create(&curses_thread, NULL, &read_input, NULL);
      initialized = true;
    }
  }
=}

reactor MotorControl {
  input brkOn: bool
  input angle: int
  output torque: int
  state braking: bool = true

  //@label Set torque to zero if car is braking
  reaction(brkOn) -> torque {=
    self->braking = brkOn->value;
    lf_set(torque, 0);
  =}

  //@label Adjust torque unless car is braking
  reaction(angle) -> torque {=
    if (!self->braking) {
          lf_set(torque, calc_motor_torque(angle->value));
        } else if (angle->value > 0){
          printw("Cannot accelerate; release brake pedal first.\n");
        }
  =}
}

reactor BrakePedal {
  output angle: int
  output applied: bool

  physical action a(0, 1 msec, "replace"): int
  state last: int = 1

  // @label Setup callback
  reaction(startup) -> a {=
    pedals.brake = a;
    init_sensors();
  =}

  // @label Output reported angle
  reaction(a) -> angle, applied {=
    if (self->last != a->value) {
      if (self->last == 0) {
        lf_set(applied, true); // zero to nonzero
      } else if (a->value == 0) {
        lf_set(applied, false); // nonzero to zero
      }

      self->last = a->value;

       lf_set(angle, a->value);
    }
  =}
}

reactor Accelerator {
  state pedal: int = -1
  physical action a(0, 2 msec, "replace"): int
  output angle: int
  state last: int = 0

  // @label Setup callback
  reaction(startup) -> a {=
    pedals.accelerate = a;
    init_sensors();
  =}

  // @label Output reported angle
  reaction(a) -> angle {=
    if (self->last != a->value) {
      lf_set(angle, a->value);
      self->last = a->value;
    }
  =}
}

// @label Apply the requested force
reactor Brakes {
  input force: int

  // @label Reaction with deadline
  reaction(force) {=
    printw("Adjusting brake power to %dN; on time!\n", force->value);
  =} deadline(2 msec) {=
    printw("Adjusting brake power to %dN; too late!\n", force->value);
  =}
}

// @label Apply the requested torque
reactor Motor {
  input torque: int

  // @label Reaction with deadline
  reaction(torque) {=
    printw("Adjusting engine torque to %dNm; on time!\n", torque->value);
  =} deadline(3 msec) {=
    printw("Adjusting engine torque to %dNm; too late!\n", torque->value);
  =}
}

// @label Adjust the force
reactor BrakeControl {
  input angle: int
  output force: int

  reaction(angle) -> force {=
    lf_set(force, calc_brake_force(angle->value));
  =}
}

/** Reactor that implements a simplified power train control module. */
main reactor PowerTrain {
  bp = new BrakePedal()
  a = new Accelerator()
  bc = new BrakeControl()
  mc = new MotorControl()
  b = new Brakes()
  m = new Motor()

  bp.angle -> bc.angle
  bc.force -> b.force
  bp.applied -> mc.brkOn
  mc.torque -> m.torque
  a.angle -> mc.angle
}
